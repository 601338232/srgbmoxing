<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>SignalRGB 设备模型编辑器</title>
<style>
  :root { --panel-w: 320px; --canvas-size: 700px; }
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Microsoft Yahei", Arial; margin: 18px; background: #fafafa; color:#222;}
  h1 { margin: 0 0 10px 0; font-size:18px;}
  .wrap { display:flex; gap:18px; align-items:flex-start; }
  .left { width: var(--panel-w); background:#fff; padding:12px; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.08); }
  .left label { display:block; margin:8px 0 4px; font-size:13px; }
  input[type="text"], input[type="number"] { width:100%; box-sizing:border-box; padding:6px 8px; border:1px solid #ddd; border-radius:6px; }
  button { margin:8px 6px 0 0; padding:7px 12px; border-radius:6px; border:0; background:#2f7efc; color:#fff; cursor:pointer;}
  button.secondary { background:#666; }
  button.warn { background:#e44; }
  .meta { font-size:13px; margin-top:6px; }
  .canvas-wrap { background:#fff; padding:12px; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.08); }
  canvas { background: linear-gradient(#fff,#fff); display:block; border:1px solid #ccc; cursor:crosshair; }
  .controls { margin-top:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  pre { background:#0f1724; color:#e6eef8; padding:10px; border-radius:6px; max-height:220px; overflow:auto; font-size:12px; }
  .stat { font-weight:600; margin-top:8px; }
  .hint { font-size:12px; color:#666; margin-top:6px; }
  .fileinput { display:none; }
  footer { margin-top:12px; font-size:12px; color:#666; }
  .row { display:flex; gap:8px; }
  .auto-gen { font-size:11px; color:#2f7efc; margin-top:2px; }
</style>
</head>
<body>
  <h1>SignalRGB 设备模型可视化编辑器</h1>
  <div class="wrap">
    <div class="left">
      <label>产品名（ProductName）</label>
      <input id="prodName" type="text" placeholder="请输入产品名">
      <div class="auto-gen">导出的JSON中会自动添加灯珠数量，如: 产品名 - 12LED</div>
      
      <label>品牌（Brand）</label>
      <input id="brand" type="text" placeholder="留空将自动设为CompGen">
      <div class="auto-gen">留空时品牌将自动设为: CompGen</div>
      
      <div style="display:flex; gap:8px; margin-top:8px;">
        <div style="flex:1;">
          <label>宽度（Width，格数）</label>
          <input id="gridW" type="number" min="1" value="15">
        </div>
        <div style="flex:1;">
          <label>高度（Height，格数）</label>
          <input id="gridH" type="number" min="1" value="15">
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div style="flex:1;">
          <label for="cellPx">格子像素大小（px，可调整）：<span id="cellPxValue">32</span></label>
          <input id="cellPx" type="range" min="6" max="64" step="2" value="32">
        </div>
      </div>
      
      <div class="controls">
        <button id="btnGen">生成网格</button>
        <button id="btnReset" class="secondary">重置灯珠</button>
        <button id="btnClear" class="warn">清空所有</button>
      </div>

      <div style="margin-top:10px;">
        <label>导入 / 导出</label>
        <div class="controls">
          <input id="fileIn" class="fileinput" type="file" accept=".json">
          <button id="btnImport">导入</button>
          <button id="btnExport">导出</button>
        </div>
      </div>

      <div style="margin-top:10px; border-top:1px solid #eee; padding-top:10px;">
        <label>阵列复制 (Array Duplicate)</label>
        <div class="row">
            <div style="flex:1;">
                <label for="dupCount" style="font-size:11px; margin:0 0 2px;">份数</label>
                <input id="dupCount" type="number" min="1" value="2">
            </div>
            <div style="flex:2; display:flex; align-items:flex-end; gap:6px;">
                 <button id="btnDuplicateH" style="width:50%; margin:0;">横向复制</button>
                 <button id="btnDuplicateV" style="width:50%; margin:0;" class="secondary">纵向复制</button>
            </div>
        </div>
        <div class="hint">将当前灯珠作为一组，向右或向下复制指定的总份数。</div>
      </div>
      <label style="margin-top:10px;">设备图像（PNG）</label>
      <input id="imgFile" type="file" accept="image/png">
      
      <div style="display:flex; gap:8px; margin-top:8px;">
          <div style="flex:1;">
              <label for="imgOffsetX" style="font-size:13px; margin:0 0 2px;">图像 X 偏移 (px)</label>
              <input id="imgOffsetX" type="number" value="0">
          </div>
          <div style="flex:1;">
              <label for="imgOffsetY" style="font-size:13px; margin:0 0 2px;">图像 Y 偏移 (px)</label>
              <input id="imgOffsetY" type="number" value="0">
          </div>
      </div>
      <div style="flex:1; margin-top:8px;">
          <label for="imgScale" style="font-size:13px; margin:0 0 2px;">图像缩放比例（Scale）</label>
          <input id="imgScale" type="number" min="0.1" step="0.1" value="1.0">
      </div>
      
      <div class="controls" style="margin-top:4px; gap:4px;">
        <input type="checkbox" id="showImg" checked style="width:auto;">
        <label for="showImg" style="font-size:13px; margin:0;">在画布上显示图像</label>
        <label for="imgOpacity" style="font-size:13px; margin-left:8px;">不透明度:</label>
        <input type="range" id="imgOpacity" min="0.1" max="1" step="0.1" value="0.5" style="width:100px;">
      </div>

      <img id="imgPreview" style="max-width:100%; margin-top:6px; display:none; border:1px solid #ccc; border-radius:4px;">

      <div class="meta">
        <div class="stat">灯珠数量： <span id="ledCount">0</span></div>
        <div class="stat">当前模式：<span id="mode">点选放置 / 拖动移动 / 滑动绘制</span></div>
      </div>

      <div style="margin-top:10px;">
        <label>JSON 预览</label>
        <pre id="jsonOut">{}</pre>
      </div>

      <footer>
        使用方法：生成网格 → 单击格子添加 LED → 双击删除 → 拖动已放置 LED 可移动 → 按住空格子滑动可连续绘制。<br>
        导出时保存到（C:\Users\用户名\文档\WhirlwindFX\Components）。
      </footer>
    </div>

    <div class="canvas-wrap">
      <canvas id="gridCanvas" width="700" height="700"></canvas>
    </div>
  </div>

<script>
const canvas = document.getElementById('gridCanvas');
const ctx = canvas.getContext('2d');

let gridW = parseInt(document.getElementById('gridW').value,10);
let gridH = parseInt(document.getElementById('gridH').value,10);
let cellPx = 32; // **修改点 3：cellPx 初始值设置为默认值，实际值从 init 块中读取**
// **修改点 4：增大偏移量，避免坐标数字被遮挡**
let offset = {x:40,y:40};
let leds = [];
let dragging = null;
let drawing = false;
let hoverCell = null;
let imageBase64 = "";

let backgroundImage = null;
let showImageOnCanvas = true;
let imageOpacity = 0.5;

// 工具函数
function getAutoProductName() {
  const baseName = document.getElementById('prodName').value || 'CustomFan';
  const ledCount = leds.length;
  if (/\s*x\d+$/.test(baseName)) {
      return `${baseName} - ${ledCount}LED`;
  }
  return `${baseName} - ${ledCount}LED`;
}
function getBrand() {
  const brand = document.getElementById('brand').value.trim();
  return brand || 'CompGen';
}
function resizeCanvasByCell() {
  const size = Math.max(gridW * cellPx, gridH * cellPx) + offset.x*2;
  canvas.width = Math.max(size, 300);
  canvas.height = Math.max(size, 300);
}
function genGrid() {
  gridW = Math.max(1, parseInt(document.getElementById('gridW').value,10));
  gridH = Math.max(1, parseInt(document.getElementById('gridH').value,10));
  // **修改点 5：genGrid 中不再从 DOM 读取 cellPx，仅做最小值校验**
  cellPx = Math.max(6, cellPx); 
  resizeCanvasByCell();
  leds = leds.filter(p => p.x >=0 && p.x < gridW && p.y >=0 && p.y < gridH);
  drawAll();
}
function clearLeds() { leds = []; updateUI(); drawAll(); }
function resetLeds() { leds = []; drawAll(); updateUI(); }
function pointToCell(px, py) {
  const x = Math.floor((px - offset.x) / cellPx);
  const y = Math.floor((py - offset.y) / cellPx);
  if (x < 0 || x >= gridW || y < 0 || y >= gridH) return null;
  return {x, y};
}
function findLedAtCell(cell) {
  if (!cell) return -1;
  for (let i=0;i<leds.length;i++){
    if (leds[i].x === cell.x && leds[i].y === cell.y) return i;
  }
  return -1;
}
function updateUI() {
  document.getElementById('ledCount').textContent = leds.length;
  document.getElementById('jsonOut').textContent = JSON.stringify(buildJsonPreview(), null, 2);
}
function buildJsonPreview() {
  const prod = document.getElementById('prodName').value || 'CustomFan';
  const brand = getBrand();
  const coords = leds.map(p => [p.x, p.y]);
  const out = {
    ProductName: prod,
    DisplayName: prod,
    Brand: brand,
    Type: "custom",
    LedCount: coords.length,
    Width: gridW,
    Height: gridH,
    LedMapping: coords.map((_,i)=>i),
    LedCoordinates: coords,
    LedNames: coords.map((_,i)=>"Led"+(i+1))
  };
  if (imageBase64) out.Image = imageBase64;
  return out;
}
function buildExportJson() {
  const prod = getAutoProductName();
  const brand = getBrand();
  const coords = leds.map(p => [p.x, p.y]);
  const out = {
    ProductName: prod,
    DisplayName: prod,
    Brand: brand,
    Type: "custom",
    LedCount: coords.length,
    Width: gridW,
    Height: gridH,
    LedMapping: coords.map((_,i)=>i),
    LedCoordinates: coords,
    LedNames: coords.map((_,i)=>"Led"+(i+1))
  };
  if (imageBase64) out.Image = imageBase64;
  return out;
}
function clearAll() {
    clearLeds();
    backgroundImage = null;
    imageBase64 = "";
    document.getElementById('imgPreview').style.display = "none";
    document.getElementById('imgPreview').src = "";
    document.getElementById('imgFile').value = '';
    updateUI();
}

// 绘制
function drawAll() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // **修改点 6：应用图像偏移和缩放**
  if (backgroundImage && showImageOnCanvas) {
    const imgOffsetX = parseFloat(document.getElementById('imgOffsetX')?.value) || 0;
    const imgOffsetY = parseFloat(document.getElementById('imgOffsetY')?.value) || 0;
    const imgScale = parseFloat(document.getElementById('imgScale')?.value) || 1.0; 

    const baseWidth = gridW * cellPx;
    const baseHeight = gridH * cellPx;
    const drawWidth = baseWidth * imgScale;
    const drawHeight = baseHeight * imgScale;
    
    ctx.globalAlpha = imageOpacity;
    ctx.drawImage(
        backgroundImage, 
        offset.x + imgOffsetX, 
        offset.y + imgOffsetY, 
        drawWidth, 
        drawHeight
    );
    ctx.globalAlpha = 1.0;
  }

  ctx.strokeStyle = '#999';
  ctx.lineWidth = 1;
  for (let i=0;i<=gridW;i++) {
    const x = offset.x + i*cellPx;
    ctx.beginPath(); ctx.moveTo(x, offset.y); ctx.lineTo(x, offset.y + gridH*cellPx); ctx.stroke();
  }
  for (let j=0;j<=gridH;j++) {
    const y = offset.y + j*cellPx;
    ctx.beginPath(); ctx.moveTo(offset.x, y); ctx.lineTo(offset.x + gridW*cellPx, y); ctx.stroke();
  }
  ctx.fillStyle = '#111'; ctx.font = '14px sans-serif'; ctx.textAlign = 'center';
  for (let i=0;i<gridW;i++) ctx.fillText(i, offset.x + i*cellPx + cellPx/2, offset.y - 8);
  ctx.textAlign = 'right';
  for (let j=0;j<gridH;j++) ctx.fillText(j, offset.x - 8, offset.y + j*cellPx + cellPx/2 + 6);
  if (hoverCell) {
    ctx.fillStyle = 'rgba(47,126,252,0.12)';
    ctx.fillRect(offset.x + hoverCell.x*cellPx+1, offset.y + hoverCell.y*cellPx+1, cellPx-1, cellPx-1);
  }
  leds.forEach((pt, idx)=>{
    if (pt.animX === undefined) pt.animX = pt.x;
    if (pt.animY === undefined) pt.animY = pt.y;
    pt.animX += (pt.x - pt.animX)*0.2;
    pt.animY += (pt.y - pt.animY)*0.2;
    const cx = offset.x + pt.animX*cellPx + cellPx/2;
    const cy = offset.y + pt.animY*cellPx + cellPx/2;
    ctx.beginPath(); ctx.fillStyle = '#2f7efc';
    ctx.arc(cx, cy, Math.max(6, cellPx/3), 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = `${Math.max(10, cellPx/6)}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(idx, cx, cy);
    if (dragging === idx) {
      ctx.strokeStyle = '#ffa500'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(cx, cy, Math.max(6, cellPx/3)+4, 0, Math.PI*2); ctx.stroke();
    }
  });
  requestAnimationFrame(drawAll);
}

// UPDATED FEATURE: Array Duplicate Logic (Horizontal & Vertical)
function duplicateLeds(direction) {
    const copies = parseInt(document.getElementById('dupCount').value, 10);
    if (isNaN(copies) || copies <= 1) {
        alert("份数必须是大于1的数字。");
        return;
    }
    if (leds.length === 0) {
        alert("画布上没有灯珠可以复制。");
        return;
    }

    const baseLeds = JSON.parse(JSON.stringify(leds));
    const baseWidth = gridW;
    const baseHeight = gridH;
    const newLeds = [];

    for (let i = 0; i < copies; i++) {
        const offsetX = (direction === 'horizontal') ? baseWidth * i : 0;
        const offsetY = (direction === 'vertical') ? baseHeight * i : 0;
        
        baseLeds.forEach(led => {
            newLeds.push({ x: led.x + offsetX, y: led.y + offsetY });
        });
    }

    leds = newLeds;

    if (direction === 'horizontal') {
        gridW = baseWidth * copies;
        document.getElementById('gridW').value = gridW;
    } else { // vertical
        gridH = baseHeight * copies;
        document.getElementById('gridH').value = gridH;
    }

    let prodNameInput = document.getElementById('prodName');
    let currentName = prodNameInput.value.replace(/\s*-\s*\d+LED\s*$/, '').replace(/\s*x\d+\s*$/, '').trim();
    prodNameInput.value = `${currentName} x${copies}`;

    resizeCanvasByCell();
    updateUI();
}

// 鼠标事件
canvas.addEventListener('mousedown', (e)=>{
  const r = canvas.getBoundingClientRect();
  const p = {x: e.clientX - r.left, y: e.clientY - r.top};
  const cell = pointToCell(p.x, p.y);
  if (!cell) return;
  const idx = findLedAtCell(cell);
  if (idx >= 0) {
    dragging = idx;
  } else {
    leds.push({x: cell.x, y: cell.y});
    updateUI();
    drawing = true;
  }
});
canvas.addEventListener('mousemove', (e)=>{
  const r = canvas.getBoundingClientRect();
  const p = {x: e.clientX - r.left, y: e.clientY - r.top};
  const cell = pointToCell(p.x, p.y);
  hoverCell = cell;
  if (dragging !== null && cell) {
    const targetIdx = findLedAtCell(cell);
    if (targetIdx === -1) {
        leds[dragging].x = cell.x;
        leds[dragging].y = cell.y;
        updateUI();
    }
  }
  if (drawing && cell) {
    const idx = findLedAtCell(cell);
    if (idx === -1) {
      leds.push({x: cell.x, y: cell.y});
      updateUI();
    }
  }
});
canvas.addEventListener('mouseup', ()=>{ if(dragging !== null) { updateUI(); } dragging = null; drawing = false; });
canvas.addEventListener('mouseleave', ()=>{ hoverCell=null; drawing=false; if(dragging !== null) { updateUI(); } dragging=null; });
canvas.addEventListener('dblclick', (e)=>{
  const r = canvas.getBoundingClientRect();
  const p = {x:e.clientX-r.left, y:e.clientY-r.top};
  const cell = pointToCell(p.x, p.y);
  const idx = findLedAtCell(cell);
  if(idx>=0){ leds.splice(idx,1); updateUI(); }
});

// 按钮
document.getElementById('btnGen').addEventListener('click', ()=>genGrid());
document.getElementById('btnReset').addEventListener('click', ()=>resetLeds());
document.getElementById('btnClear').addEventListener('click', ()=>{ if(confirm('清空所有灯珠和图片？')) clearAll(); });
document.getElementById('btnDuplicateH').addEventListener('click', () => duplicateLeds('horizontal'));
document.getElementById('btnDuplicateV').addEventListener('click', () => duplicateLeds('vertical'));

document.getElementById('btnImport').addEventListener('click', ()=>document.getElementById('fileIn').click());
document.getElementById('fileIn').addEventListener('change', (ev)=>{
  const f = ev.target.files[0]; if(!f) return;
  const reader = new FileReader();
  reader.onload = (e)=>{
    try{
      const data = JSON.parse(e.target.result);
      if(data.Width) { document.getElementById('gridW').value=data.Width; gridW=data.Width; }
      if(data.Height){ document.getElementById('gridH').value=data.Height; gridH=data.Height; }
      if(data.ProductName) document.getElementById('prodName').value=data.ProductName;
      if(data.Brand) document.getElementById('brand').value=data.Brand;
      leds=[];
      if(Array.isArray(data.LedCoordinates)) data.LedCoordinates.forEach(c=>{ if(Array.isArray(c)&&c.length>=2){ const x=parseInt(c[0],10),y=parseInt(c[1],10); if(!Number.isNaN(x)&&!Number.isNaN(y)) leds.push({x,y}); } });
      
      backgroundImage = null;
      imageBase64 = "";
      if(data.Image){
        imageBase64 = data.Image;
        const imageUrl = "data:image/png;base64," + data.Image;
        document.getElementById('imgPreview').src = imageUrl;
        document.getElementById('imgPreview').style.display = "block";
        backgroundImage = new Image();
        backgroundImage.src = imageUrl;
      } else {
        document.getElementById('imgPreview').style.display = "none";
      }

      resizeCanvasByCell(); updateUI();
    }catch(err){ alert('导入 JSON 失败：'+err); }
  };
  reader.readAsText(f); ev.target.value='';
});

document.getElementById('btnExport').addEventListener('click', ()=>{
  const json = buildExportJson();
  const blob = new Blob([JSON.stringify(json,null,2)],{type:'application/json'});
  const a = document.createElement('a'); a.href=URL.createObjectURL(blob);
  a.download = (json.ProductName||'model')+'.json'; a.click();
});

document.getElementById('imgFile').addEventListener('change', e=>{
  const f = e.target.files[0];
  if (!f) return;
  const reader = new FileReader();
  reader.onload = ev => {
    const imageUrl = ev.target.result;
    imageBase64 = imageUrl.replace(/^data:image\/png;base64,/, "");
    document.getElementById('imgPreview').src = imageUrl;
    document.getElementById('imgPreview').style.display = "block";
    
    backgroundImage = new Image();
    backgroundImage.src = imageUrl;

    alert("图片已加载，将在导出时写入 JSON");
    updateUI();
  };
  reader.readAsDataURL(f);
});

document.getElementById('showImg').addEventListener('change', (e) => {
  showImageOnCanvas = e.target.checked;
});
document.getElementById('imgOpacity').addEventListener('input', (e) => {
  imageOpacity = parseFloat(e.target.value);
});

// **修改点 7：新增图像位置和缩放的实时监听**
document.getElementById('imgOffsetX').addEventListener('input', drawAll);
document.getElementById('imgOffsetY').addEventListener('input', drawAll);
document.getElementById('imgScale').addEventListener('input', drawAll);


// **修改点 8：新增 cellPx 滑动条的事件监听（优化卡顿/不灵敏问题）**
const cellPxInput = document.getElementById('cellPx');
const cellPxDisplay = document.getElementById('cellPxValue');

// 使用 'change' 触发 genGrid 避免卡顿（只在滑动停止时更新网格）
cellPxInput.addEventListener('change', (e) => {
    cellPx = parseInt(e.target.value, 10);
    genGrid(); 
});

// 使用 'input' 仅更新显示值，保持灵敏度
cellPxInput.addEventListener('input', (e) => {
    if (cellPxDisplay) cellPxDisplay.textContent = e.target.value;
});


// init
// **修改点 9：初始化时同步 cellPx 的值**
cellPx = parseInt(cellPxInput.value, 10);
if (cellPxDisplay) cellPxDisplay.textContent = cellPx;

resizeCanvasByCell();
drawAll();
updateUI();
</script>
</body>
</html>
